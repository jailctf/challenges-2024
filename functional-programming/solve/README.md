# functional programming

The intended solution is to generate a Python object whose `hash()` equals `0x1337133713371337`. Since tuples are hashable, their hash is also deterministic. Arbitary "binary" tuples can be generated by repeatedly using `enumerate`, `reversed`, and `list`. For example,

```py
next(iter(reversed(list(enumerate(range(2)))))) == (1, 1)
next(iter(list(enumerate(reversed(list(enumerate(range(2)))))))) == (0, (1, 1))
next(iter(list(enumerate(reversed(list(enumerate(reversed(list(enumerate(range(2))))))))))) == (0, (1, (0, 0)))
```

It remains to generate a preimage of `hash()` efficiently, without brute forcing over the entire `2^64` search space. We can see that the [`tuplehash`](https://github.com/python/cpython/blob/3.12/Objects/tupleobject.c#L319) implementation in CPython has a single accumulator variable that updates via some mathematical formula as a function of the current item in the tuple:

```py
Py_uhash_t acc = _PyHASH_XXPRIME_5;
for (i = 0; i < len; i++) {
    Py_uhash_t lane = PyObject_Hash(item[i]);
    if (lane == (Py_uhash_t)-1) {
        return -1;
    }
    acc += lane * _PyHASH_XXPRIME_2;
    acc = _PyHASH_XXROTATE(acc);
    acc *= _PyHASH_XXPRIME_1;
}
```

Most notably, the transformation is **bijective**, which allows us to perform a meet-in-the-middle attack. This decreases the time of finding a preimage from `2^64` to `2^32`! My [implementation](brute.c) in C takes ~25 mins to find a solution.
